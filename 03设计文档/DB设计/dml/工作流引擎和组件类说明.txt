

系统管控
（1）临时数据缓存清理，每个项目可以配置过期天数自动清理，以及提供主动清理接口，实验工作台运行、实验离线调度运行、实验在线调度运行，仅缓存最后一次运行的数据输出
（2）数据输出端口schema分析开关，系统参数WK_FLOW_SCHEMA_MAX_FIELDS控制是否为超限中断，默认值512字段数，以及组件类是否支持动态分析
（3）实验最多节点数量WK_FLOW_MAX_NODES默认512
（4）web服务组件的数据输出端口不支持schema分析，且流出链接标记为Is-Web-Link

实验管理 & 工作流引擎
（1）组件参数更新，先校验新老参数值是否发生变化，脚本更新走脚本接口内部再调用关联组件的参数校验方法
（2）组件数据输出端口schema更新失败时，自动对所有下游节点的schema做状态重置
（3）读数据组件的数据查看走viewDataTableByName，其他组件输出数据查看走viewDataTableByID
（4）通过ModuleBoard.getMapper().find("class_path")方法查找组件类bean对象
（5）任一输入端口schema状态非正常，停止动态分析，并将该状态传递到下游
（6）实验调度部署，保存关联工作流快照信息，部署版本更新或者删除自动清理先前的临时数据表、临时模型、临时报告等记录
（7）实验删除和节点删除，删除过程中遇到的逻辑错误忽略，如果是节点删除遇到，该节点同时不进删除队列表

工作流加锁和版本号控制
（1）工作流锁unlocked时，允许操作工作流删除、工作流编辑（节点增删、节点位置、节点参数更新、节点撤销删除、节点连线）、工作流副本、工作流运行，副本和运行处理前对工作流加锁，前者快照完成后解锁，后者运行结束后解锁
（2）工作流锁locked时，仅允许副本和运行对工作流相关表做更新，同时不需要更新版本号，期间打回工作流编辑和删除
（3）工作流加锁和解锁操作，都会更新版本号和校验版本号（先查询对比版本号，再更新版本号，判断影响行数），工作流编辑和删除的版本号更新校验也类似
（4）工作流查询类，不受加锁限制
（5）加锁和解锁，更新lock state和lock msg
（6）副本相关信息，no version，last_snapshot_id，next_snapshot_version，==>FlowMapper
（7）运行相关信息，no version，last_job_id，
（8）简易更新，no version，例如工作流名称、概要、描述

（X）schema analyze走异步执行，不受加锁和版本号限制，出错时自动中止无法分析的路径 ？？？


数据文件--统计分析（异步 ？ 计算组件运行中 ？）
数据文件--拷贝异步
慢速处理内容--适当选择异步处理

////////////////////////////////////////////////////////////////////////////////////////////////

CharType类，负责特征层面的事件捕获，承担特征值发生创建（对象创建）、删除（对象删除）、查询（对象展开）、更新（对象更新）时的自定义处理，以及特征值正确性和合法性的常规校验
Module类，负责节点层面的事件捕获，承担节点发生创建、删除、查询、参数更新、任务运行时的逻辑校验和自定义处理，以及节点输出端口schema分析

CharType类&Module类节点事件流处理说明：
（1）Create Node Begin --> CharType.validateValue --> CharType.onCreateValue --> ${Engine Insert Node & Port & Schema & Parameter} --> CharType.onQueryValue --> Module.onCheckParameter --> ${Engine Accept Change} -->
	 ${Engine Cur Node Schema Analyze} --> Create Node End

（2）Delete Node Begin --> ${Engine Fetch Node Content} --> CharType.onDeleteValue --> ${Engine Delete Node & Port & Schema & Parameter & Link & Global Parameter} --> Engine Push(Node Delete Queue) --> 
	 ${Engine Loop(Downstream Node Schema Clean<Empty Schema>)} --> Delete Node End

Support Canvas Node & Snapshot Node
（3）Query Node Begin --> ${Engine Fetch Node Content} --> ${Engine Global Parameter Override(From Scheduler Execution)} --> CharType.onQueryValue --> Module.onCheckParameter --> 
	 ${Engine Accept Change} --> Query Node End

（4）Update Parameter Begin --> CharType.validateValue --> ${Engine Fetch Node Content} --> CharType.onUpdateValue --> CharType.onQueryValue --> Module.onCheckParameter --> ${Engine Accept Change} -->
	 ${Engine Loop(Cur & Downstream Node Schema Analyze)} --> Update Parameter End

（5）Inbound Link Begin --> ${Engine Loop(Cur & Downstream Node Schema Analyze)} --> Inbound Link End

（6）Outbound Link Begin --> ${Engine Nothing To Do} --> Outbound Link End

（7）Update Script Begin --> ${Engine Fetch Node Content & Script Context} --> CharType.onUpdateValue --> CharType.onQueryValue --> Module.onCheckParameter --> ${Engine Accept Change} -->
	 ${Engine Loop(Cur & Downstream Node Schema Analyze)} --> Update Script End

Support Canvas Node & Snapshot Node
（8）Execute Task Begin --> ${Engine Fetch Task Context} --> ${Engine Query Node} --> CharType.onQueryValue<Execution, Optimzation Execution, Input> --> ${Engine Complete Task Context(Output)} -->
	 Module.onTaskExecution --> CharType.onCreateValue<Output> -->
	 ${Engine Complete Task Context(Output)} --> ${Engine Submit Task} --> ${Engine Monitor Task Return} --> CharType.onUpdateValue<Output> --> ${Engine Accept Return(Task|Node)} -->
	 Execute Task End

Support Canvas Node & Snapshot Node
（9）Execute Job Begin --> ${Engine Fetch Job Context} --> ${Engine Analyze Effective Job Content} --> ${Engine Analyze Job Path} --> ${Engine Analyze Header Task} --> ${Engine Loop(Execute Task<By Path>)} -->
	 ${Engine Accept Finish(None|Flow|Scheduler)} --> Execute Job End

（10）Create Global Parameter Begin --> ${Engine Check Allow Global} --> CharType.validateValue --> CharType.onCreateValue --> ${Engine Insert Global Parameter} --> Create Global Parameter End

（11）Delete Global Parameter Begin --> ${Engine Fetch Global Parameter} --> CharType.onDeleteValue --> ${Engine Delete Global Parameter} --> Delete Global Parameter End

（12）Query Global Parameter Begin --> ${Engine Fetch Global Parameter} --> CharType.onQueryValue --> Query Global Parameter End

（13）Update Global Parameter Begin --> ${Engine Fetch Global Parameter} --> CharType.validateValue --> CharType.onUpdateValue --> ${Engine Update Global Parameter} -- Update Global Parameter End



schema仅是辅助用，不对节点状态产生任何影响
checkParameter：
	仅对非空值组件参数做逻辑校验
	仅对组件参数产生告警消息
	-- required特征值存在空值时，以及参数逻辑校验不通过，由引擎统计设置为节点未就绪状态、节点告警、参数告警

////////////////////////////////////////////////////////////////////////////////////////////////

组件基类（在组件参数特征类型捕获事件通过基础上，对组件的特定业务逻辑做进一步校验判断，###Module类不捕获执行调优参数事件，仅CharType类捕获执行调优参数事件）


public class NodeContext {
	WorkflowContxt workflowContext;
	Node node;
	String warningMsg; （parameter）
}

public class TaskExecutionContext {
	WorkflowContext workflowContext;
	JobExecutionContext jobExecutionContext;
	Node node;
	ExecutionTask executionTask;
	String warningMsg;
}

@service
public interface IModule extends InitializingBean {
	//方法失败或异常抛出moduleException，工作流组件类实现该接口，对节点事件捕获，适当封装一些中间abstract类加以复用
	
	
	////////////////////////////////////组件bean初始化//////////////////////////////////////////
	
	//必须
	@postconstruct
	void register() {
		ModuleBoard.getMapper().put(this.getClass().getName(), this);
	}
	
	
	//////////////////////////////////节点参数校验事件相关//////////////////////////////////////
	
	//是否捕获参数校验事件
	//返回false，否
	//返回true，是
	boolean catchCheckParameter();

	//校验参数处理，例如：数据表读取组件需要校验对应的数据表是否正常，存在情况下，设置节点状态为ready，否则为not ready
	//返回更新部分的node-content，NULL代表无更新（仅限节点信息，参数信息）
	NodeContentDto onCheckParameter(NodeContentDto<node, parameter, inputPorts, outputPorts>, updateParameterList);
	
	
	///////////////////////////////////任务执行事件相关/////////////////////////////////////////
	
	//是否捕获任务执行事件
	//返回false，否
	//返回true，是
	boolean catchTaskExecution();
	
	//任务执行事件处理，例如：读数据表将输出内容"OUT@DataTable-t1<M>"特征值置为"CCP@TableName"特征值对应数据表的ID值
	//返回更新部分的task-context信息，NULL代表无更新
	TaskContextDto onTaskExecution(TaskContextDto<task, component, execution, optimize_execution, input, output, parameter>);
	
	
	////////////////////////////////////运行动态模拟相关////////////////////////////////////////
	
	//是否支持动态分析数据输出端口schema
	//返回false，不支持
	//返回true，支持
	boolean supportAnalyzeSchema();
	
	//触发分析数据输出端口schema的特征代码集合
	//返回特征代码集合，NULL代表无触发特征
	paremeterCodeSet analyzeSchemaTriggerParameters() {
		static final HashSet<parameterCode> triggerParameters = new HashSet<String>() {{
			add("xxx");
			add("yyy");
		}};
		resturn triggerParameters;
	};
	
	//分析数据输出端口schema
	//返回更新部分的数据输出端schema列表，NULL代表无更新
	OutportSchemaDtoList analyzeSchema(NodeContentDto<node, parameter, inputPorts, outputPorts>)；
	
	//组件菜单配置，数据库中配置，模版怎么定义，还是暂时先放前端工程里配置
}




//////////////////////////////////////////////////////////////////

工作流发布、工作流调度、在线预测服务的相关表结构后面再进一步完善。

｛数据上传 + 服务调度 | 外部数据 + 服务调度｝

工作流发布（运行成功后可发布，需要桥接/重定向/投影类似功能的全局输入输出组件）
工作流调度流水（定时任务，服务API）
工作流调度参数（全局参数传入值）
工作流调度缓存（仅缓存最后一次，临时数据采用动态表、动态模型等等，全局输入输出组件如何设计待商榷）

在线工作流调度服务发布
在线工作流调度服务的资源和接口信息
在线工作流调度服务的调用记录和统计信息


人工操作的运行，定义为调试模式，快照允许缓存全量数据
其他操作的运行，定义为发布模式，快照仅保留概要数据

【在线预测服务，以项目为单位对模型预测服务分组】
在线预测服务发布（普通模型和临时模型都可以发布，前者直接关联模型id，后者关联flowid+nodeid+charid）
在线预测服务的资源和接口信息 （运行容器、URL和签名认证）
在线预测服务的接口调用记录和统计信息

【实时流式计算 + 在线预测服务，支撑在线预测场景】
